<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>Local AI Chat</title>
    <link href="data/tailwind.min.css" rel="stylesheet">
    <script src="data/marked.min.js"></script>
    <script src="data/purify.min.js"></script>

    <style>
        :root {
            --bg-primary: #111827;
            /* gray-900 */
            --bg-secondary: #1f2937;
            /* gray-800 */
            --bg-accent-color: #374151;
            /* gray-700 */
            --text-main: #f3f4f6;
            /* gray-200 */
            --text-muted: #9ca3af;
            /* gray-400 */
            --accent-color: #4f46e5;
            /* indigo-600 */
            --accent-hover: #4338ca;
            /* indigo-700 */
            --border-color: #4b5563;
            /* gray-600 */
            --bg-accent-color: #1f2937;
            /* New background accent color - you can change this */

             --markdown-quote: #d1d5db; /* A nice light gray for quotes */


        }

        .message-content strong {
  color: var(--markdown-bold, var(--text-main));
}

        body {
            background-color: var(--bg-primary);
            color: var(--text-main);
        }

         * {
        border-color: var(--bg-secondary) !important;
            }


        #theme-selector {
            background-color: var(--bg-accent-color) !important;
            color: var(--text-main) !important;
            border: 1px solid var(--border-color) !important;
        }

        /* Ensure custom color pickers match the theme */
        #custom-colors input[type="color"] {
            background-color: var(--bg-secondary) !important;
            border: 1px solid var(--border-color) !important;
        }

        /* Markdown styling */
        .message-content blockquote {
  border-left: 4px solid var(--accent-color);
  padding-left: 1rem;
  margin: 1rem 0;
  color: var(--text-main);
  font-style: italic;
}
.message-content em {
  color: var(--markdown-italic);
  font-style: italic;
}

        .message-content .markdown-quote p {

            color: var(--markdown-quote);
            /* Changed default to black */
        }




        .message-content em {
            font-style: italic;
            color: var(--markdown-italic, #a5b4fc);
        }

        .message-content code {
            background-color: var(--markdown-code-bg, #374151);
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-family: monospace;
            color: var(--text-main, #f3f4f6);
            display: block;
            width: 100%;
        }


        .message-content a {
            color: var(--markdown-link, #60a5fa);
            text-decoration: underline;
        }

        .message-content h1,
        .message-content h2,
        .message-content h3 {
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            font-weight: bold;
            color: var(--text-main, #f3f4f6);
        }

        .message-content ul {
            margin-left: 1.5rem;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        #main-container.sidebar-hidden #sidebar {
            transform: translateX(-100%) !important;
        }

        #main-container.sidebar-hidden #chat-area {
            margin-left: 0 !important;
        }

        /* Also add this to ensure proper layout behavior */
        #main-container.sidebar-hidden .absolute {
            position: absolute !important;
        }

        #sidebar {

            width: 20rem;
            /* or whatever sidebar size you want */
            transition: transform 0.3s ease-in-out;


        }


        #chat-area {

            flex-grow: 1;
            transition: margin-left 0.3s ease-in-out;

        }




        @keyframes pulse {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }


        .message-bubble:hover .message-actions {
            visibility: visible;
            opacity: 1;

        }

        /* Message bubble styling */
        .message-bubble {
            display: flex;
            align-items: flex-start;
            gap: 1rem;

            margin-bottom: 1rem;
        }

        .message-bubble.justify-end {
            justify-content: flex-end;
        }

        .message-bubble .message-content {
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
        }

        /* User message styling */


        .streaming-content {

            background-color: var(--bg-accent-color) !important;
            color: var(--text-main);
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;

        }

        .streaming-content blockquote {
  border-left: 4px solid var(--accent-color);
  padding-left: 1rem;
  margin: 1rem 0;
  color: var(--markdown-quote);
  font-style: italic;
}
        /* Assistant message styling */
        /* Assistant message styling */


        /* Message actions (hidden by default, visible on hover) */
        .message-actions {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s;
            display: flex;
            gap: 0.25rem;
            background-color: var(--bg-secondary) !important;
            padding: 0.25rem;
            border-radius: 9999px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .message-bubble:hover .message-actions {
            visibility: visible;
            opacity: 1;
        }



        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            color: var(--text-muted);
        }


        /* Mevcut CSS'i Korumak ve Geliştirmek İçin */

        /* Varsayılan (Mobil) Stil: Sidebar Kapalıyken (Başlangıç Durumu) */
        #sidebar {
            transform: translateX(-100%);
            /* Başlangıçta gizli */
            transition: transform 0.3s ease-in-out;
        }

        .sidebar-hidden #sidebar {
            transform: translateX(-100%);
        }

        .sidebar-hidden #chat-area {
            margin-left: 0 !important;
        }

        #chat-area {
            margin-left: 0;
            /* Başlangıçta tam genişlik */
            transition: margin-left 0.3s ease-in-out;
        }

        .chat-input-area {
            position: fixed !important;
            /* This fixes it to viewport */
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
            /* High z-index to stay on top */
            background-color: var(--bg-accent-color) !important;
        }

        /* Background accent color for messages and UI elements */
        .bg-accent-color {
            background-color: var(--bg-accent-color) !important;
        }


        .character-item.selected,
        .character-item:hover {
            color: var(--text-main);
        }

        /* User message styling using bg-accent-color */
        .message-bubble .user-message {
            background-color: var(--accent-color) !important;
            color: var(--text-main);

            margin-left: auto;
            text-align: right;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
        }

        /* Assistant message styling using bg-accent-color */
        .message-bubble .assistant-message {
            background-color: var(--bg-accent-color) !important;
            color: var(--text-main);
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
        }

        /* Other elements that use bg-tertiary */
        .bg-tertiary {
            background-color: var(--bg-accent-color) !important;
        }


        /* Replace all instances of "bg-tertiary" styling with this: */
        .chat-input-area {
            background-color: var(--bg-accent-color) !important;
            padding-bottom: env(safe-area-inset-bottom);
            /* Add this line */
            position: relative;
            /* Add this line */
        }


        /* Add this to your existing styles */
        #edit-message-text {
            resize: none;
        }


        /* Update chat input area to use bg-accent-color instead of bg-tertiary */
        .chat-input-area .message-input {
            background-color: rgba(255, 255, 255, 0.1) !important;
            /* Semi-transparent for better contrast */
            color: white !important;
            border: none !important;
        }

        /* Update chat item styling to use bg-accent-color */
        .chat-item,
        .character-item {
            background-color: var(--bg-accent-color) !important;
        }



        /* Ensure the send button uses accent color properly */
        #chat-form .bg-accent-color,
        #chat-form .bg-accent-color:hover {
            background-color: var(--accent-color) !important;
        }

        /* Make sure textarea inherits proper styling */
        .message-input {
            background-color: rgba(255, 255, 255, 0.1) !important;
            /* Semi-transparent for better contrast */
            color: white !important;
            border: none !important;
        }


        #main-container {
            /* Ana kapsayıcınızın flex/grid yapısını burada ayarlayın */
            display: flex;
            height: 100vh;
            /* Veya kullandığınız yapı */
        }

        /* Add these styles to your existing style section */
        #chats-for-*.chat-item {
            position: relative;
        }

        button[title="Delete Chat"] {
            opacity: 0.3;
            transition: opacity 0.2s ease;
        }

        button[title="Delete Chat"]:hover {
            opacity: 1;
        }

        /* Add these new CSS rules */
        /* Ensure consistent accent color application */
        .character-item {
            transition: background-color 0.2s ease;
        }

        .character-item.selected,
        .character-item:hover {
            background-color: var(--accent-color) !important;
            color: white !important;
        }

        /* Chat item selection styling */
        .chat-item.selected,
        .chat-item:hover {
            background-color: var(--accent-color) !important;
            opacity: 0.8;
        }

        /* Make sure chat items have proper hover states */
        #chats-for-* button[data-chat-id] {
            transition: background-color 0.2s ease;
        }

        #chats-for-* button[data-chat-id].selected,
        #chats-for-* button[data-chat-id]:hover {
            background-color: var(--accent-color) !important;
            opacity: 0.8;
        }

        /* Message input area styling */
        .chat-input-area .bg-accent-color {
            background-color: var(--accent-color) !important;
        }

        /* Ensure the send button uses accent color properly */
        #chat-form .bg-accent-color,
        #chat-form .bg-accent-color:hover {
            background-color: var(--accent-color) !important;
        }


        button[title="Delete Chat"] {
            opacity: 0.3;
            transition: opacity 0.2s ease;
        }

        button[title="Delete Chat"]:hover {
            opacity: 1;
        }

        /* Ensure delete buttons in chat list look consistent */
        #chats-for-* button[title="Delete Chat"] {
            background-color: transparent !important;
        }

        /* Ensure chat items have proper selection styling */
        #chats-for-* button[data-chat-id] {
            transition: background-color 0.2s ease;
        }

        /* This ensures the selected chat stays highlighted with accent color */
        #chats-for-* button[data-chat-id].selected,
        #chats-for-* button[data-chat-id][data-chat-id="${selectedChatId}"] {
            background-color: var(--accent-color) !important;
            opacity: 0.8;
            color: white !important;
        }

        /* Ensure chat items have proper hover states */
        #chats-for-* button[data-chat-id]:hover {
            background-color: var(--accent-hover) !important;
            opacity: 0.8;
            color: white !important;
        }



/* Add this to your existing CSS */
.message-content q {
    color: var(--markdown-quote) !important;
    font-style: italic;
}

/* Also ensure any span or other elements with quote styling work */
.message-content .quote,
.message-content .inline-quote {
    color: var(--markdown-quote) !important;
    font-style: italic;
}

        /* Sidebar AÇIKKEN (sidebar-hidden sınıfı YOK) mobil stil */
        /* Kenar çubuğunun varsayılan olarak mobil görünümde sol tarafta görünmesini sağlar */




        #main-container.sidebar-hidden #chat-area {
            margin-left: 0 !important;
        }

        /* Masaüstü (md ve üzeri) için mevcut düzeninizi koruyun */
        /* Add this to your existing styles */

        @media (max-width: 767px) {
            #sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: 17rem;
                /* Your sidebar width */
                height: 100vh;
                transform: translateX(0);

                transition: transform 0.3s ease-in-out;
            }

            #chat-area {
                margin-left: 17rem;
                /* Same as sidebar width */

            }
        }

        #main-container.sidebar-hidden #sidebar {
            transform: translateX(-100%) !important;
        }

        #main-container.sidebar-hidden #chat-area {
            margin-left: 0 !important;
        }

        /* Ensure the chat window scrolls independently */
        #chat-window {
            height: calc(100vh - 120px);
            /* Adjust based on your header/footer height */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Make settings area scrollable */
        #settings-accordion {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }





        /* Try this complete mobile-specific solution */
        @media screen and (max-width: 768px) {
            .chat-input-area {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 9999 !important;
                padding-bottom: env(safe-area-inset-bottom) !important;
                transform: translateZ(0);
                /* Force hardware acceleration */
            }

            #main-container {
                display: flex;
                height: 100vh;
            }
        }

        /* Desktop layout */
        @media (min-width: 768px) {
            #sidebar {
                position: static;
                /* Not fixed on desktop */
                width: 20rem;
                height: auto;
                transform: none !important;
            }

            #chat-area {

                flex-grow: 1;
            }
        }

        /* For the full block container */
        .markdown-code-block {
            width: 100%;
            margin: 1rem 0;
            overflow-x: auto;
        }

        /* For inline code */
        .markdown-inline-code {
            background-color: #374151;
            /* bg-gray-700 */
            color: white;
            padding: 0.25rem 0.5rem;
            /* px-1 py-0.5 */
            border-radius: 0.25rem;
            /* rounded */
            font-family: monospace;
        }

        /* For block code (full width) */
        .markdown-block-code {
            background-color: #1f2937;
            /* bg-gray-800 */
            color: white;
            padding: 1rem;
            /* p-4 */
            border-radius: 0.5rem;
            /* rounded */
            font-family: monospace;
            font-size: 0.875rem;
            /* text-sm */
            overflow-x: auto;
            width: 100%;
            box-sizing: border-box;
        }

        /* Alternative full-width block code with better spacing */
        .code-block-container {
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
            width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>

<body class="font-sans antialiased">




    <!-- Main Container -->
    <div id="main-container" class="relative flex h-screen overflow-hidden">

        <!-- Left Sidebar -->
        <aside id="sidebar"
            class="w-70 bg-secondary flex-shrink-0 p-3 flex flex-col border-r border-border-color absolute md:relative inset-y-0 left-0 z-20">
            <h1 class="text-2xl font-bold mb-4 text-center">Local AI Chat</h1>
            <button id="add-char-btn"
                class="w-full bg-accent-color hover:bg-accent-hover text-main font-bold py-2 px-4 rounded-lg transition duration-200 mb-4">
                + Add New Character
            </button>

            <div class="flex-grow overflow-y-auto" id="character-list">
                <!-- Character list will be populated by JS -->
            </div>

            <!-- Settings Accordion -->
            <!-- In your settings accordion section, update this part -->
            <div id="settings-accordion"
                class="mt-4 border-t border-border-color pt-4 space-y-2 overflow-y-auto max-h-[calc(100vh-200px)]">

                <!-- User Persona -->
                <!-- Inside the "Your Persona" details section -->
                <details class="bg-accent-color /50 rounded-lg p-2">
                    <summary class="font-semibold cursor-pointer">Your Persona</summary>
                    <textarea id="user-persona" rows="3" class="w-full mt-2 bg-secondary rounded p-2 text-sm"
                        placeholder="Describe yourself to the AI..."></textarea>
                    <div class="mt-2">
                        <label class="block text-sm font-medium mb-1">User Avatar URL</label>
                        <input type="text" id="user-avatar-url"
                            class="w-full bg-accent-color/50 border border-border-color rounded p-2 text-sm"
                            placeholder="'data/Icons/User.png'">
                    </div>
                    <!-- ADD THIS NEW SECTION FOR UPLOAD -->
                    <div class="mt-2">
                        <label class="block text-sm font-medium mb-1">Upload User Avatar</label>
                        <input type="file" id="user-avatar-upload" accept="image/*"
                            class="w-full bg-accent-color/50 border border-border-color rounded p-2 text-sm">
                    </div>
                </details>
                <details class="bg-accent-color /50 rounded-lg p-2">
                    <summary class="font-semibold cursor-pointer">AI Settings</summary>
                    <div class="mt-2 space-y-3 p-1">
                        <div>
                            <div class="slider-label"><span>Temperature</span><span id="temp-value">0.7</span></div>
                            <input type="range" id="temperature" min="0" max="2" step="0.1" value="0.7" class="w-full">
                        </div>
                        <div>
                            <div class="slider-label"><span>Repetition Penalty</span><span id="rep-pen-value">1.1</span>
                            </div>
                            <input type="range" id="repetition_penalty" min="1" max="2" step="0.05" value="1.1"
                                class="w-full">
                        </div>
                        <div>
                            <div class="slider-label"><span>Min P (Top P)</span><span id="min-p-value">0.95</span></div>
                            <input type="range" id="min_p" min="0" max="1" step="0.05" value="0.95" class="w-full">
                        </div>
                    </div>
                </details>
                <!-- Theme Settings -->
                <details class="bg-accent-color /50 rounded-lg p-2">
                    <summary class="font-semibold cursor-pointer">Theme</summary>
                    <div class="mt-2 space-y-2">
                        <select id="theme-selector" class="w-full bg-accent-color/50 p-2 rounded">
                            <option value="dark">Dark (Default)</option>
                            <option value="light">Light</option>
                            <option value="pink">Pink</option>
                            <option value="cappuccino">Cappuccino</option>
                            <option value="sepia">Sepia</option>
                            <option value="forest">Forest</option>
                            <option value="ocean">Ocean</option>
                            <option value="glacier">Glacier</option>
                            <option value="earthy">Earthy</option>
                            <option value="lavender">Lavender</option>

                            <option value="custom">Custom</option>
                        </select>



                        <div id="custom-colors" class="hidden space-y-2 p-1 border-t border-border-color mt-2">
                            <label class="flex items-center justify-between text-sm"><span>Primary BG</span><input
                                    type="color" data-css-var="--bg-primary" class="h-6 w-10"></label>
                            <label class="flex items-center justify-between text-sm"><span>Secondary BG</span><input
                                    type="color" data-css-var="--bg-secondary" class="h-6 w-10"></label>
                            <label class="flex items-center justify-between text-sm"><span>Accent</span><input
                                    type="color" data-css-var="--accent-color" class="h-6 w-10"></label>
                            <!-- In your Theme Settings section, add this to the custom colors -->
                            <label class="flex items-center justify-between text-sm"><span>Background
                                    Accent</span><input type="color" data-css-var="--bg-accent-color"
                                    class="h-6 w-10"></label>

                            <label class="flex items-center justify-between text-sm"><span>Text</span><input
                                    type="color" data-css-var="--text-main" class="h-6 w-10"></label>
                            <!-- Markdown color settings -->
                            <div class="mt-3 pt-3 border-t border-border-color">
                                <h4 class="font-semibold mb-2">Markdown Colors</h4>
                                <label class="flex items-center justify-between text-sm">
                                    <span>Quote Text</span>
                                    <input type="color" data-css-var="--markdown-quote" value="#d1d5db" class="h-6 w-10">
                                  </label>
                                <label class="flex items-center justify-between text-sm"><span>Italic Text</span><input
                                        type="color" data-css-var="--markdown-italic" value="#a5b4fc"
                                        class="h-6 w-10"></label>
                                 <label class="flex items-center justify-between text-sm"><span>Bold Text</span><input type="color" data-css-var="--markdown-bold" value="#a5b4fc"
                                            class="h-6 w-10"></label>
                                <label class="flex items-center justify-between text-sm"><span>Code
                                        Background</span><input type="color" data-css-var="--markdown-code-bg"
                                        value="#374151" class="h-6 w-10"></label>
                                <label class="flex items-center justify-between text-sm"><span>Link Color</span><input
                                        type="color" data-css-var="--markdown-link" value="#60a5fa"
                                        class="h-6 w-10"></label>
                            </div>

                        </div>

                    </div>
                </details>
            </div>
        </aside>

        <main id="chat-area" class="w-full flex flex-col bg-primary">
            <header
                class="bg-secondary/80 backdrop-blur-sm p-3 border-b border-border-color flex items-center justify-between flex-shrink-0">
                <div class="flex items-center">

                    <!-- Toggle button moved outside sidebar -->
                    <button id="sidebar-toggle" class="p-2 mr-2 rounded-full hover:bg-accent-color  ">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 6h16M4 12h16m-7 6h7"></path>
                        </svg>
                    </button>

                    <h2 id="chat-header-text" class="text-xl font-bold truncate">Select a character</h2>
                </div>
                <div id="stream-controls" class="flex hidden">
                    <button id="cancel-stream-btn"
                        class="bg-accent-color text-white px-2 py-1 rounded-lg transition-colors flex items-center gap-1">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                        Stop Generating...
                    </button>

                </div>
                <button id="new-chat-btn" class="hidden p-2 rounded-full hover:bg-accent-color " title="New Chat">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                </button>
            </header>

            <div id="chat-window" class="flex-grow p-3 overflow-y-auto">
                <!-- Welcome/Empty State -->
                <div id="empty-state" class="flex h-full items-center justify-center">
                    <div class="text-center text-muted">
                        <svg class="mx-auto h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                        </svg>
                        <p class="mt-2">Select a character to begin chatting.</p>
                    </div>
                </div>
            </div>
            <div id="chat-input-area" class="p-3 bg-accent-color">
                <div id="streaming-indicator" class="text-center text-sm text-gray-500 py-2 animate-pulse hidden">
                    AI is typing...
                </div>

                <form id="chat-form" class="flex items-center gap-2">
                    <textarea id="message-input" placeholder="Message..." rows="1"
                        class="flex-1 p-3 rounded-lg bg-accent-color/50 text-white border-none resize-none focus:outline-none message-input"></textarea>

                    <!-- Replace send button with cancel button when streaming -->
                    <div id="button-container">
                        <button type="submit" class="p-2 rounded-full bg-accent-color hover:bg-accent-color/80">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                            </svg>
                        </button>
                    </div>
                </form>






            </div>

        </main>
    </div>

    <!-- Add Character Modal -->
    <!-- Add Character Modal -->
    <div id="add-char-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-secondary bg-accent-color rounded-lg p-8 w-full max-w-lg shadow-xl">
            <h2 class="text-2xl font-bold mb-4">Add New Character</h2>
            <form id="add-char-form">
                <div class="mb-4">
                    <label for="char-name" class="block text-sm font-medium mb-1">Character Name</label>
                    <input type="text" id="char-name" required
                        class="w-full bg-accent-color  border border-border-color rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-accent-color">
                </div>
                <div class="mb-4">
                    <label for="char-avatar" class="block text-sm font-medium mb-1">Avatar URL (Optional, PNG
                        recommended)</label>
                    <input type="file" id="char-avatar" accept="image/*"
                        class="w-full bg-accent-color  border border-border-color rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-accent-color">
                </div>
                <div class="mb-6">
                    <label for="char-desc" class="block text-sm font-medium mb-1">Character Description /
                        Persona</label>
                    <textarea id="char-desc" rows="6" required
                        class="w-full bg-accent-color  border border-border-color rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-accent-color"></textarea>
                </div>
                <div class="flex justify-end space-x-4">
                    <button type="button" id="cancel-add-char"
                        class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
                    <button type="submit"
                        class="bg-accent-color hover:bg-accent-hover text-white font-bold py-2 px-4 rounded-lg">Save
                        Character</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Edit Character Modal -->
    <div id="edit-char-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-secondary rounded-lg p-8 w-full max-w-lg shadow-xl">
            <h2 class="text-2xl font-bold mb-4">Edit Character</h2>
            <form id="edit-char-form">
                <input type="hidden" id="edit-char-id">
                <div class="mb-4">
                    <label for="edit-char-name" class="block text-sm font-medium mb-1">Character Name</label>
                    <input type="text" id="edit-char-name" required
                        class="w-full bg-accent-color  border border-border-color rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-accent-color">
                </div>
                <div class="mb-4">
                    <label for="edit-char-avatar" class="block text-sm font-medium mb-1">Avatar URL or Upload</label>
                    <input type="file" id="edit-char-avatar" accept="image/*"
                        class="w-full bg-accent-color  border border-border-color rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-accent-color">
                    <p class="text-xs text-muted mt-1">Upload a new avatar or enter URL</p>
                </div>
                <div class="mb-6">
                    <label for="edit-char-desc" class="block text-sm font-medium mb-1">Character Description /
                        Persona</label>
                    <textarea id="edit-char-desc" rows="6" required
                        class="w-full bg-accent-color  border border-border-color rounded-lg p-2 focus:outline-none focus:ring-2 focus:ring-accent-color"></textarea>
                </div>
                <div class="flex justify-end space-x-4">
                    <button type="button" id="cancel-edit-char"
                        class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
                    <button type="submit"
                        class="bg-accent-color hover:bg-accent-hover text-white font-bold py-2 px-4 rounded-lg">Save
                        Changes</button>
                </div>
            </form>
        </div>
    
    </div>

    <script>
        // --- Self-invoking function to encapsulate logic ---
        (() => {
            // --- DOM Elements ---

            marked.setOptions({
  breaks: true, // Convert \n to <br>
  gfm: true,    // GitHub Flavored Markdown
  sanitize: false, // We’ll sanitize separately
});


            const $ = (selector) => document.querySelector(selector);
            const $$ = (selector) => document.querySelectorAll(selector);

            const editCharModal = $('#edit-char-modal');
            const editCharForm = $('#edit-char-form');
            const cancelEditCharBtn = $('#cancel-edit-char');
            const editCharIdInput = $('#edit-char-id');
            const editCharNameInput = $('#edit-char-name');
            const editCharAvatarInput = $('#edit-char-avatar');
            const editCharDescInput = $('#edit-char-desc');
            const characterList = $('#character-list');
            const chatHeaderText = $('#chat-header-text');
            const chatWindow = $('#chat-window');
            const chatInputArea = $('#chat-input-area');
            const chatForm = $('#chat-form');
            const messageInput = $('#message-input');
            const addCharBtn = $('#add-char-btn');
            const addCharModal = $('#add-char-modal');
            const addCharForm = $('#add-char-form');
            const cancelAddCharBtn = $('#cancel-add-char');
            const sidebarToggle = $('#sidebar-toggle');
            const mainContainer = $('#main-container');
            const newChatBtn = $('#new-chat-btn');
            const emptyState = $('#empty-state');
            const userPersonaInput = $('#user-persona');

            // Settings
            const tempSlider = $('#temperature');
            const tempValue = $('#temp-value');
            const repPenSlider = $('#repetition_penalty');
            const repPenValue = $('#rep-pen-value');
            const minPSlider = $('#min_p');
            const minPValue = $('#min-p-value');
            const userAvatarInput = $('#user-avatar-url');
            const userAvatarUpload = $('#user-avatar-upload'); // ADD THIS LINE

            // Theming
            const themeSelector = $('#theme-selector');
            const customColorsContainer = $('#custom-colors');
            const colorPickers = $$('#custom-colors input[type="color"]');

            // --- State ---
            let isUserAtBottom = true;
            let isStreaming = false;
            let abortController = null;
            let isFullscreen = false;
            let selectedCharacterId = null;
            let selectedChatId = null;
            let characters = [];
            let chatHistory = [];
            let isGenerating = false;
            let shouldAutoScroll = true;
            const streamingMessages = new Map(); // Track different streaming messages by ID

            // --- API URL ---
            const API_BASE_URL = window.location.origin;

            // --- THEME MANAGEMENT ---
            // Add this to the PRESET_THEMES object:
            const PRESET_THEMES = {
    dark: {
        '--bg-primary': '#121212',
        '--bg-secondary': '#1e1e1e',
        '--bg-accent-color': '#252525',
        '--accent-color': '#6c5ce7',
        '--text-main': '#e0e0e0',
        '--markdown-quote': '#b0bec5',
        '--markdown-italic': '#a29bfe',
        '--markdown-code-bg': '#2d2d2d',
        '--markdown-link': '#55efc4'
    },
    pink: {
    '--bg-primary': '#2b0e1c',            // Deep rosewood
    '--bg-secondary': '#3c1628',          // Dark berry
    '--bg-accent-color': '#5a1f3a',       // Plum-pink accent
    '--accent-color': '#ff5c8d',          // Bright punchy pink
    '--text-main': '#ffe9ef',             // Soft light pink
    '--markdown-quote': '#d81b60',        // Vivid raspberry
    '--markdown-italic': '#f48fb1',       // Ballet pink
    '--markdown-code-bg': '#451728',      // Wine background
    '--markdown-link': '#ff80ab'          // Cotton candy
}
,

 
 cappuccino: {
    '--bg-primary': '#141420',          // Darker base (almost black-purple)
  '--bg-secondary': '#0f0f14',        // Even darker mantle
  '--bg-accent-color': '#2a2a3b',     // Deeper surface shade
  '--accent-color': '#d87e54',        // Warm peach, slightly more saturated for pop
  '--text-main': '#bfc7d8',           // Softer light text, less bright than original
  '--markdown-quote': '#e8bdb6',      // Muted flamingo pink
  '--markdown-italic': '#e9a778',     // Softer peachy tone
  '--markdown-code-bg': '#2a2a3b',    // Same as bg-accent-color for consistency
  '--markdown-link': '#7da7f9'   
}


,
    sepia: {
        '--bg-primary': '#f8f3e6',
        '--bg-secondary': '#f0e7d5',
        '--bg-accent-color': '#e8dbc4',
        '--accent-color': '#795548',
        '--text-main': '#3e2723',
        '--markdown-quote': '#6d4c41',
        '--markdown-italic': '#8d6e63',
        '--markdown-code-bg': '#efebe9',
        '--markdown-link': '#a1887f'
    },
    forest: {
        '--bg-primary': '#0d2b1f',
        '--bg-secondary': '#1b4a32',
        '--bg-accent-color': '#2a5f42',
        '--accent-color': '#66bb6a',
        '--text-main': '#e8f5e9',
        '--markdown-quote': '#c8e6c9',
        '--markdown-italic': '#a5d6a7',
        '--markdown-code-bg': '#1b3b2a',
        '--markdown-link': '#81c784'
    },
    ocean: {
        '--bg-primary': '#012a4a',
        '--bg-secondary': '#01497c',
        '--bg-accent-color': '#014f86',
        '--accent-color': '#4895ef',
        '--text-main': '#f1f9ff',
        '--markdown-quote': '#a9d6e5',
        '--markdown-italic': '#89c2d9',
        '--markdown-code-bg': '#023047',
        '--markdown-link': '#64b5f6'
    },
    glacier: {
        '--bg-primary': '#12232e',              // Dark slate blue
    '--bg-secondary': '#1b3a4b',            // Deep ocean blue
    '--bg-accent-color': '#27576e',         // Muted steel blue
    '--accent-color': '#4aa3df',            // Bright glacier blue
    '--text-main': '#cbe7f0',               // Soft icy blue
    '--markdown-quote': '#3fa7b0',          // Teal-ish cyan
    '--markdown-italic': '#70c1d6',         // Pale cyan
    '--markdown-code-bg': '#1e4054',        // Dark steel blue background
    '--markdown-link': '#5bc0de'            // Bright blue link
    },
    earthy: {
      
'--bg-primary': '#2e1a0f',              // Rich brown
    '--bg-secondary': '#3b2415',            // Slightly warmer
    '--bg-accent-color': '#5e3921',         // Warm chestnut
    '--accent-color': '#f4a261',            // Pumpkin orange
    '--text-main': '#fff3e0',               // Cream
    '--markdown-quote': '#e76f51',          // Burnt coral
    '--markdown-italic': '#f6bd60',         // Golden wheat
    '--markdown-code-bg': '#4e342e',        // Deep bark
    '--markdown-link': '#ffa07a'            // Soft salmon

},
lavender: {
    '--bg-primary': '#1c152b',           // Midnight lavender
    '--bg-secondary': '#2a1f3d',         // Plum shadow
    '--bg-accent-color': '#4b3a66',      // Dusty purple
    '--accent-color': '#a58fd5',         // Light lavender accent
    '--text-main': '#f2eaff',            // Pale lavender-white
    '--markdown-quote': '#7c5fb3',       // Regal purple
    '--markdown-italic': '#bba3e0',      // Muted violet
    '--markdown-code-bg': '#332544',     // Deep lilac
    '--markdown-link': '#d1b3ff'         // Lavender-pink
},
    light: {
        '--bg-primary': '#ffffff',
        '--bg-secondary': '#f8f9fa',
        '--bg-accent-color': '#e9ecef',
        '--accent-color': '#e9ecef',
        '--text-main': '#212529',
        '--markdown-quote': '#6c757d',
        '--markdown-italic': '#0d6efd',
        '--markdown-code-bg': '#f8f9fa',
        '--markdown-link': '#0a58ca'
    }
};

            function createFullscreenButton() {
                // Create fullscreen toggle button
                const fullscreenBtn = document.createElement('button');
                fullscreenBtn.id = 'fullscreen-btn';
                fullscreenBtn.textContent = 'Enter Fullscreen';
                fullscreenBtn.className = 'w-full bg-accent-color hover:bg-accent-hover text-white font-bold py-2 px-4 rounded-lg transition duration-200 mt-2';

                fullscreenBtn.onclick = toggleFullscreen;


                const themeSettings = document.querySelector('#settings-accordion details:last-child');
                if (themeSettings) {
                    const themeContent = themeSettings.querySelector('div');
                    if (themeContent) {
                        themeContent.appendChild(fullscreenBtn);
                    }
                }
            }

            function toggleFullscreen() {
                const element = document.documentElement;

                if (!isFullscreen) {
                    // Enter fullscreen
                    if (element.requestFullscreen) {
                        element.requestFullscreen();
                    } else if (element.webkitRequestFullscreen) {
                        element.webkitRequestFullscreen();
                    }
                    isFullscreen = true;

                    // Update button text
                    const fullscreenBtn = document.getElementById('fullscreen-btn');
                    if (fullscreenBtn) {
                        fullscreenBtn.textContent = 'Exit Fullscreen';
                    }
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    }
                    isFullscreen = false;

                    // Update button text
                    const fullscreenBtn = document.getElementById('fullscreen-btn');
                    if (fullscreenBtn) {
                        fullscreenBtn.textContent = 'Enter Fullscreen';
                    }
                }
            }

            // Add this to your existing event listeners section:
            document.addEventListener('DOMContentLoaded', function () {
                // Check if we're on mobile and add the button
                if (/Mobi|Android/i.test(navigator.userAgent)) {
                    createFullscreenButton();

                    // Listen for fullscreen change events
                    document.addEventListener('fullscreenchange', function () {
                        isFullscreen = !isFullscreen;
                        const fullscreenBtn = document.getElementById('fullscreen-btn');
                        if (fullscreenBtn) {
                            fullscreenBtn.textContent = isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen';
                        }
                    });

                    // For Safari
                    document.addEventListener('webkitfullscreenchange', function () {
                        isFullscreen = !isFullscreen;
                        const fullscreenBtn = document.getElementById('fullscreen-btn');
                        if (fullscreenBtn) {
                            fullscreenBtn.textContent = isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen';
                        }
                    });
                }
            });

            // Fixed: Proper toggle function that works with the button


            const applyTheme = (themeName) => {
                const theme = PRESET_THEMES[themeName];
                if (theme) {
                    for (const [key, value] of Object.entries(theme)) {
                        document.documentElement.style.setProperty(key, value);
                    }
                    customColorsContainer.classList.add('hidden');
                } else if (themeName === 'custom') {
                    customColorsContainer.classList.remove('hidden');
                    const customTheme = JSON.parse(localStorage.getItem('customTheme')) || {};
                    for (const [key, value] of Object.entries(customTheme)) {
                        document.documentElement.style.setProperty(key, value);
                    }
                    updateColorPickers();
                }
            };

            const updateColorPickers = () => {
                colorPickers.forEach(picker => {
                    const cssVar = picker.dataset.cssVar;
                    picker.value = getComputedStyle(document.documentElement).getPropertyValue(cssVar).trim();
                });
            };

            const updateChatSelection = (charId) => {
                const allChatButtons = document.querySelectorAll(`#chats-for-${charId} button[data-chat-id]`);
                allChatButtons.forEach(btn => {
                    if (btn.dataset.chatId === selectedChatId) {
                        btn.classList.add('bg-accent-color');
                        btn.style.backgroundColor = 'var(--accent-color)';
                    } else {
                        btn.classList.remove('bg-accent-color');
                    }
                });
            };

            // Add a fullscreen button or trigger on first user interaction
            // Add this to your existing JavaScript



            const saveAndApplyCustomColor = (cssVar, value) => {
                document.documentElement.style.setProperty(cssVar, value);
                let customTheme = JSON.parse(localStorage.getItem('customTheme')) || {};
                customTheme[cssVar] = value;
                localStorage.setItem('customTheme', JSON.stringify(customTheme));
            };

            // --- API Functions ---
            const apiCall = async (endpoint, options = {}) => {
                try {
                    const response = await fetch(`${API_BASE_URL}/api${endpoint}`, options);
                    if (!response.ok) {
                        const errData = await response.json();
                        throw new Error(errData.error || `HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                } catch (error) {
                    console.error(`API call to ${endpoint} failed:`, error);

                    throw error;
                }
            };

            // --- Character & Chat List Functions ---
            const fetchAndRenderCharacters = async () => {
                characters = await apiCall('/characters');
                characterList.innerHTML = '';

                if (characters.length === 0) {
                    // Show a message when no characters exist
                    characterList.innerHTML = '<p class="text-center text-muted p-3">No characters yet. Add one to get started!</p>';
                    return;
                }

                characters.forEach(char => {
                    const charDiv = document.createElement('div');
                    charDiv.innerHTML = `
<div data-id="${char.id}" class="character-item w-full flex items-center mt-2 p-2 rounded-lg cursor-pointer ${selectedCharacterId === char.id ? 'bg-accent-color text-white' : 'hover:bg-accent-color '}">
    <img src="${char.avatar_url || 'data/Icons/AI.png'}" class="w-12 h-12 rounded-full mr-3 object-cover">
    <span class="font-semibold">${char.name}</span>
    <div class="ml-auto flex space-x-1">
        <button data-edit-char="${char.id}" class="p-1 hover:text-blue-400" title="Edit Character">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
        </button>
        <button data-delete-char="${char.id}" class="p-1 hover:text-red-400" title="Delete Character">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
        </button>
    </div>
</div>
<div id="chats-for-${char.id}" class="ml-2 mt-1 space-y-1 ${selectedCharacterId === char.id ? '' : 'hidden'}"></div>
`;
                    characterList.appendChild(charDiv);
                });
            };


            // Modify the fetchAndRenderChatList function to include delete button for chats:
            // Updated fetchAndRenderChatList function:
            const fetchAndRenderChatList = async (charId) => {
                const chatIds = await apiCall(`/characters/${charId}/chats`);
                const container = $(`#chats-for-${charId}`);
                if (!container) return;

                container.innerHTML = '';

                if (chatIds.length === 0) {
                    const newChatBtn = document.createElement('button');
                    newChatBtn.textContent = 'Start New Chat';
                    newChatBtn.className = 'block w-full text-left text-sm p-1 px-2 rounded hover:bg-accent-color ';
                    newChatBtn.addEventListener('click', async () => {
                        const newChatId = await createNewChat(charId);
                        await fetchAndRenderChatList(charId);
                        selectChat(newChatId);
                    });
                    container.appendChild(newChatBtn);
                    return;
                }

                // Render existing chats
                chatIds.forEach(chatId => {
                    const chatBtn = document.createElement('button');
                    chatBtn.dataset.chatId = chatId;
                    chatBtn.className = `block w-full text-left text-sm p-1 px-2 rounded relative ${selectedChatId === chatId ? 'bg-accent-color' : 'hover:bg-accent-color '}`;
                    const date = new Date(parseInt(chatId) * 1000);
                    const formattedDate = date.toLocaleString('en-US', {
                        month: 'numeric',
                        day: 'numeric',
                        year: 'numeric',
                        hour: 'numeric',
                        minute: '2-digit',
                        hour12: true
                    });
                    chatBtn.textContent = `Chat - ${formattedDate}`;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = `<svg class="w-4 h-4 text-red-400 hover:text-red-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
        </svg>`;
                    deleteBtn.className = "absolute right-2 top-1/2 transform -translate-y-1/2 p-0.5";
                    deleteBtn.title = "Delete Chat";
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteChat(charId, chatId);
                    });
                    chatBtn.appendChild(deleteBtn);
                    container.appendChild(chatBtn);
                });

                if (selectedChatId && selectedCharacterId === charId) {
                    updateChatSelectionUI(charId, selectedChatId);
                }
            };



            // Add this function to handle character editing:
            const openEditCharacterModal = (charId) => {
                const character = characters.find(c => c.id === charId);
                if (!character) return;

                // Set form values
                editCharIdInput.value = charId;
                editCharNameInput.value = character.name;
                editCharDescInput.value = character.description;

                editCharModal.classList.remove('hidden');
            };

            // Add this function to save edited character:
            const handleSaveEditedCharacter = async (e) => {
                e.preventDefault();

                const charId = editCharIdInput.value;
                const name = editCharNameInput.value.trim();
                const description = editCharDescInput.value.trim();
                let avatar_url = '';

                // Handle avatar upload
                if (editCharAvatarInput.files && editCharAvatarInput.files[0]) {
                    const formData = new FormData();
                    formData.append('image', editCharAvatarInput.files[0]);

                    try {
                        const response = await fetch('/api/upload-image', {
                            method: 'POST',
                            body: formData
                        });
                        const result = await response.json();
                        avatar_url = result.url;
                    } catch (error) {
                        console.error('Image upload failed:', error);
                        alert('Failed to upload avatar');
                        return;
                    }
                } else {
                    const character = characters.find(c => c.id === charId);
                    if (character && character.avatar_url) {
                        avatar_url = character.avatar_url;
                    }
                }

                if (!name || !description) return;

                try {
                    // Update character on backend
                    const response = await fetch(`${API_BASE_URL}/api/characters/${charId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, description, avatar_url }),
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const updatedCharacter = await response.json();

                    editCharModal.classList.add('hidden');

                    //auto select last chat after edit

                    characters = await apiCall('/characters'); // Get fresh data including updates

                    if (selectedCharacterId) {
                        await fetchAndRenderCharacters();

                        // Re-render the chat list 
                        await fetchAndRenderChatList(selectedCharacterId);

                        // Auto-select last chat if none is selected - FIXED VERSION
                        if (!selectedChatId) {
                            try {
                                const chatIds = await apiCall(`/characters/${selectedCharacterId}/chats`);
                                if (chatIds.length > 0) {
                                    // Sort chats by timestamp in descending order to get latest first
                                    // Since chat IDs are timestamps, we can sort numerically
                                    const sortedChatIds = [...chatIds].sort((a, b) => parseInt(b) - parseInt(a));
                                    const latestChatId = sortedChatIds[0];

                                    // Select the last chat and update UI
                                    await selectChat(latestChatId);
                                }
                            } catch (error) {
                                console.error("Failed to auto-select last chat:", error);
                            }
                        } else {
                            // If a chat was already selected, just update the UI for that chat
                            if (selectedChatId) {
                                const allChatButtons = document.querySelectorAll(`#chats-for-${selectedCharacterId} button[data-chat-id]`);
                                allChatButtons.forEach(btn => {
                                    if (btn.dataset.chatId === selectedChatId) {
                                        btn.classList.add('bg-accent-color');
                                        btn.style.backgroundColor = 'var(--accent-color)';
                                    } else {
                                        btn.classList.remove('bg-accent-color');
                                    }
                                });
                            }
                        }
                    }

                } catch (error) {
                    console.error("Failed to update character:", error);
                    alert("Failed to update character");
                }
            };

            // Add this function to handle character updates via PUT request:
            const updateCharacter = async (charId, updatedData) => {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/characters/${charId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updatedData),
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                } catch (error) {
                    console.error("Failed to update character:", error);
                    throw error;
                }
            };


            const createNewChat = async (charId) => {
                const { chat_id } = await apiCall(`/characters/${charId}/chats`, { method: 'POST' });
                return chat_id;
            };

            // --- Chat Window Functions ---
            const renderChatHistory = () => {
                chatWindow.innerHTML = '';
                emptyState.classList.add('hidden');
                if (chatHistory.length === 0) {
                    chatWindow.innerHTML = '<p class="text-center text-muted">This is the beginning of your conversation.</p>';
                    return;
                }
                chatHistory.forEach((msg, index) => appendMessage(msg.role, msg.content, index));
            };


            const appendMessage = (role, text, index) => {
                const character = characters.find(c => c.id === selectedCharacterId);

                // Check if user was at the bottom before appending
                const previousIsAtBottom = isUserAtBottom;

                let avatarUrl;
                if (role === 'user') {
                    const customAvatar = localStorage.getItem('userAvatar');
                    avatarUrl = customAvatar || 'data/Icons/User.png';
                } else {
                    avatarUrl = character?.avatar_url || 'data/Icons/AI.png';
                }

                const messageBubble = document.createElement('div');
                messageBubble.className = `message-bubble ${role === 'user' ? 'justify-end' : ''}`;

                // Parse markdown with proper styling for final messages
                const parsedText = renderMarkdown(text);

                messageBubble.innerHTML = `
        <img src="${avatarUrl}" class="w-12 h-12 rounded-full object-cover ${role === 'user' ? 'order-2' : ''}">
        <div class="message-content ${role === 'user' ? 'user-message' : 'assistant-message'}">
            ${parsedText}
            <div class="message-actions absolute -top-3 ${role === 'user' ? 'left-1' : 'right-1'} flex gap-1 bg-secondary p-1 rounded-full shadow opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                <button data-index="${index}" class="regenerate-btn p-1 hover:text-green-400" title="Regenerate"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 4l1.5 1.5A9 9 0 0120.5 15M20 20l-1.5-1.5A9 9 0 003.5 9"></path></svg></button>
                <button data-index="${index}" class="edit-btn p-1 hover:text-blue-400" title="Edit"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg></button>
                <button data-index="${index}" class="delete-btn p-1 hover:text-red-400" title="Delete"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
            </div>
        </div>
    `;

                // Add hover effect to show actions
                messageBubble.classList.add('group');

                chatWindow.appendChild(messageBubble);

                // Only auto-scroll if user was at the bottom previously
                if (previousIsAtBottom) {
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                }
            };

            const updateStreamingBubble = (bubble, content) => {
                const contentElement = bubble.querySelector('.streaming-content');
                if (contentElement) {
                    // Parse markdown for streaming content with proper styling
                    let parsedText = renderMarkdown(content);

                    // Ensure CSS variables are applied even during streaming
                    parsedText = parsedText.replace(/class="markdown-italic"/g, 'class="markdown-italic" style="color: var(--markdown-italic, #a5b4fc)"');
                    parsedText = parsedText.replace(/class="markdown-link"/g, 'class="markdown-link" style="color: var(--markdown-link, #60a5fa)"');
                    parsedText = parsedText.replace(/class="markdown-quote"/g, 'class="markdown-quote" style="color: var(--markdown-quote, #f6f6f6)"');

                    contentElement.innerHTML = renderMarkdown(content);

                    // Check if user is at or near the bottom
                    const scrollTop = chatWindow.scrollTop;
                    const scrollHeight = chatWindow.scrollHeight;
                    const clientHeight = chatWindow.clientHeight;
                    const isNearBottom = (scrollHeight - scrollTop - clientHeight) < 100; // Within 100px of bottom

                    // Auto-scroll if user was at the bottom or is near bottom
                    if (isUserAtBottom || isNearBottom) {
                        chatWindow.scrollTop = chatWindow.scrollHeight;
                    }
                }
            };


            const regenerateMessage = async (index) => {
                if (isGenerating) return;
                isGenerating = true;

                const isUserAtBottom = chatWindow.scrollHeight - chatWindow.clientHeight <= chatWindow.scrollTop + 1;

                console.log("Attempting to regenerate message at index:", index);
                console.log("Selected character ID:", selectedCharacterId);
                console.log("Selected chat ID:", selectedChatId);
                console.log("Chat history length:", chatHistory.length);

                // Auto-select last chat if none is selected
                if (!selectedChatId && selectedCharacterId) {
                    console.log("No chat selected, auto-selecting last chat...");

                    try {
                        const chatIds = await apiCall(`/characters/${selectedCharacterId}/chats`);
                        if (chatIds.length > 0) {
                            const latestChatId = chatIds[chatIds.length - 1];
                            console.log("Auto-selecting last chat:", latestChatId);

                            await selectChat(latestChatId);

                            // Wait for chatHistory to load before retrying
                            const waitForChatHistory = async (retries = 10) => {
                                if (chatHistory.length > 0) {
                                    console.log("chatHistory is ready, retrying regeneration...");
                                    isGenerating = false;
                                    await regenerateMessage(index);
                                } else if (retries > 0) {
                                    setTimeout(() => waitForChatHistory(retries - 1), 100);
                                } else {
                                    console.error("Chat history not loaded after retries");
                                    isGenerating = false;
                                }
                            };

                            waitForChatHistory();
                            return;
                        } else {
                            console.error("No chats available to regenerate from");
                            isGenerating = false;
                            return;
                        }
                    } catch (error) {
                        console.error("Failed to get chat list:", error);
                        isGenerating = false;
                        return;
                    }
                }

                // Validate assistant message
                if (index <= 0 || chatHistory[index]?.role !== 'assistant') {
                    console.error("Invalid index or not an assistant message");
                    isGenerating = false;
                    return;
                }

                const userMessageIndex = index - 1;

                // Validate index range
                if (userMessageIndex < 0 || userMessageIndex >= chatHistory.length) {
                    console.error("Invalid user message index:", userMessageIndex);
                    isGenerating = false;
                    return;
                }

                const userPrompt = chatHistory[userMessageIndex]?.content;

                if (!selectedCharacterId) {
                    console.error("No character selected for regeneration");
                    isGenerating = false;
                    return;
                }

                if (!userPrompt || userPrompt.trim() === '') {
                    console.error("Empty or missing user prompt for regeneration");
                    isGenerating = false;
                    return;
                }

                const character = characters.find(c => c.id === selectedCharacterId);
                if (!character) {
                    console.error("Selected character not found in local cache");
                    isGenerating = false;
                    return;
                }

                // Add loading indicator
                const loadingIndicator = document.createElement('div');
                loadingIndicator.innerHTML = '<p class="text-center text-muted animate-pulse">Regenerating...</p>';
                chatWindow.appendChild(loadingIndicator);
                chatWindow.scrollTop = chatWindow.scrollHeight;

                try {
                    // Create abort controller for cancellation
                    abortController = new AbortController();

                    const response = await fetch(`${API_BASE_URL}/api/chat/stream`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            character_id: selectedCharacterId,
                            chat_id: selectedChatId,
                            message: userPrompt,
                            history_override: chatHistory.slice(0, index),
                            mode: 'chat',
                            user_persona: userPersonaInput.value,
                            llm_settings: getLLMSettings(),
                            system_prompt: character.description
                        }),
                        signal: abortController.signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    // Handle streaming response - create a proper streaming bubble like in handleSendMessage
                    const streamingBubble = document.createElement('div');
                    streamingBubble.className = 'message-bubble flex items-start gap-3 mb-4';
                    streamingBubble.id = `streaming-regen-${index}`; // Unique ID for regeneration

                    // Get character avatar for the assistant
                    const avatarUrl = character?.avatar_url || 'data/Icons/AI.png';

                    streamingBubble.innerHTML = `
            <img src="${avatarUrl}" class="w-12 h-12 rounded-full object-cover">
            <div class="message-content streaming-content p-3 rounded-lg bg-accent-color"></div>
        `;

                    // Hide the original message temporarily
                    const originalMessageElement = chatWindow.querySelectorAll('.message-bubble')[index];
                    if (originalMessageElement) {
                        originalMessageElement.style.display = 'none';
                    }

                    // Insert the streaming bubble at the position of the message being regenerated
                    const messageElements = chatWindow.querySelectorAll('.message-bubble');
                    if (index < messageElements.length) {
                        chatWindow.insertBefore(streamingBubble, messageElements[index]);
                    } else {
                        chatWindow.appendChild(streamingBubble);
                    }

                    // Show the cancel button during regeneration
                    const cancelControl = $('#stream-controls');
                    if (cancelControl) {
                        cancelControl.classList.remove('hidden');
                    }

                    // Handle streaming response for regeneration
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder('utf-8');

                    let assistantMessage = '';

                    while (true) {
                        const { done, value } = await reader.read();

                        if (done) break;

                        // Decode the chunk
                        const chunk = decoder.decode(value);

                        // Process streaming data
                        try {
                            const lines = chunk.split('\n\n');

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const jsonStr = line.substring(6); // Remove "data: "

                                    if (jsonStr === '[DONE]') break;

                                    try {
                                        const data = JSON.parse(jsonStr);

                                        if (data.type === 'content' && data.content) {
                                            assistantMessage += data.content;

                                            // Update the streaming bubble with new content
                                            updateStreamingBubble(streamingBubble, assistantMessage);
                                        } else if (data.type === 'done') {
                                            break; // Streaming finished
                                        }
                                    } catch (parseError) {
                                        const cleanContent = line.substring(6).trim();
                                        if (cleanContent && !cleanContent.startsWith('[')) {
                                            assistantMessage += cleanContent;
                                            updateStreamingBubble(streamingBubble, assistantMessage);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            const cleanContent = chunk.trim();
                            if (cleanContent && !cleanContent.startsWith('[')) {
                                assistantMessage += cleanContent;
                                updateStreamingBubble(streamingBubble, assistantMessage);
                            }
                        }
                    }

                    // Replace the old message with new content
                    chatHistory[index] = { ...chatHistory[index], content: assistantMessage };

                    if (streamingBubble) {
                        streamingBubble.remove();
                    }

                    // Show the original message again (it will be replaced by renderChatHistory)
                    if (originalMessageElement) {
                        originalMessageElement.style.display = '';
                    }

                    renderChatHistory();

                } catch (error) {
                    console.error("Regeneration error:", error);
                    // Show error in the streaming bubble
                    if (loadingIndicator) {
                        loadingIndicator.innerHTML = `<div class="p-3 rounded-lg bg-red-100 text-red-800">Error: ${error.message}</div>`;
                    }

                    // Restore original message display on error
                    const originalMessageElement = chatWindow.querySelectorAll('.message-bubble')[index];
                    if (originalMessageElement) {
                        originalMessageElement.style.display = '';
                    }
                } finally {
                    isGenerating = false;

                    // Hide the cancel button when done
                    const cancelControl = $('#stream-controls');
                    if (cancelControl) {
                        cancelControl.classList.add('hidden');
                    }

                    if (abortController) {
                        abortController = null;
                    }
                    try {
    // Check if we're still on the same character, then reselect the current chat
    if (selectedCharacterId && selectedChatId) {
        console.log("Re-selecting current chat after regeneration:", selectedChatId);
        await selectChat(selectedChatId);
    } else {
        // If no chat is selected currently, get the latest chat as fallback
        const chatIds = await apiCall(`/characters/${selectedCharacterId}/chats`);
        
        if (chatIds.length > 0) {
            // Sort to find the newest one (highest timestamp)
            const sortedChatIds = [...chatIds].sort((a, b) => parseInt(b) - parseInt(a));
            const latestChatId = sortedChatIds[0];
            
            console.log("Latest chat ID:", latestChatId);
            await selectChat(latestChatId);
        }
    }
} catch (error) {
    console.error("Failed to auto-select chat after regeneration:", error);
}
                }
            };

            // Add this function near your other helpers:
            const hasExistingAssistantMessage = (content) => {
                return chatHistory.some(msg =>
                    msg.role === 'assistant' && msg.content.trim() === content.trim()
                );
            };


            const deleteMessage = async (index) => {
                
                if (!selectedCharacterId || !selectedChatId) {
                    console.error("Cannot delete message: No character or chat selected");
                    return;
                }

                if (index < 0 || index >= chatHistory.length) {
                    console.error("Invalid message index for deletion:", index);
                    return;
                }

                try {
                    const { new_history } = await apiCall(`/chats/${selectedCharacterId}/${selectedChatId}/delete_message`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ index }),
                    });
                    chatHistory = new_history;
                    renderChatHistory();
                } catch (error) {
                    console.error("Failed to delete message:", error);
                }
            };

            // Add this function to your existing JavaScript (around line ~350 where other delete functions are):
            const deleteChat = async (charId, chatId) => {
                if (!confirm('Are you sure you want to delete this chat?')) return;

                try {
                    await apiCall(`/characters/${charId}/chats/${chatId}`, { method: 'DELETE' });
                    // Refresh the chat list for this character
                    await fetchAndRenderChatList(charId);

                    // If we just deleted the current chat, create a new one
                    if (selectedChatId === chatId) {
                        const newChatId = await createNewChat(charId);
                        selectChat(newChatId);
                    }
                } catch (error) {
                    console.error("Failed to delete chat:", error);
                }
            };



            // --- Selection & State Change ---
            const selectCharacter = async (charId) => {
                selectedCharacterId = charId;
                selectedChatId = null; // Reset chat selection
                const character = characters.find(c => c.id === charId);

                chatHeaderText.textContent = character.name;
                chatInputArea.classList.remove('hidden');
                newChatBtn.classList.remove('hidden');

                // Only focus on desktop or non-mobile devices
                if (!/Mobi|Android/i.test(navigator.userAgent)) {
                    messageInput.focus();
                }

                await fetchAndRenderCharacters(); // Re-render to show selection

                // Add proper highlighting for selected character
                const allCharItems = document.querySelectorAll('.character-item');
                allCharItems.forEach(item => {
                    item.classList.remove('selected');
                    if (item.dataset.id === charId) {
                        item.classList.add('selected');
                    }
                });

                await fetchAndRenderChatList(charId);
            }; const selectChat = async (chatId) => {
                selectedChatId = chatId;

                if (selectedCharacterId) {
                    await fetchAndRenderChatList(selectedCharacterId); // Re-render chat list for selection style

                    // Update UI selections properly
                    const allChatButtons = document.querySelectorAll(`#chats-for-${selectedCharacterId} button[data-chat-id]`);
                    allChatButtons.forEach(btn => {
                        if (btn.dataset.chatId === chatId) {
                            btn.classList.add('bg-accent-color');
                            btn.style.backgroundColor = 'var(--accent-color)';
                        } else {
                            btn.classList.remove('bg-accent-color');
                        }
                    });

                    // Load the chat history
                    try {
                        const response = await apiCall(`/chats/${selectedCharacterId}/${chatId}`);
                        chatHistory = response;
                        renderChatHistory();
                    } catch (error) {
                        console.error("Failed to load chat history:", error);
                    }
                }
            };

            const saveMessageToServer = async (charId, chatId, role, content) => {
                try {
                    await apiCall(`/chats/${charId}/${chatId}/add_message`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ role, content })
                    });
                    return true;
                } catch (error) {
                    console.error("Failed to save message:", error);
                    return false;
                }
            };


            const handleSendMessage = async (e) => {
                e.preventDefault();
                const message = messageInput.value.trim();
                if (!message || !selectedCharacterId || !selectedChatId || isGenerating) return;

                isGenerating = true;

                // Create unique ID for this stream
                const streamId = Date.now().toString();

                const userMessageIndex = chatHistory.length;
                // Add user message to history immediately
                chatHistory.push({ role: 'user', content: message });
                appendMessage('user', message, userMessageIndex);
                messageInput.value = '';
                messageInput.style.height = 'auto';

                // Declare assistantMessage outside the streaming loop
                let assistantMessage = '';

                // Create a placeholder for the streaming response
                const streamingBubble = document.createElement('div');
                streamingBubble.className = 'message-bubble flex items-start gap-3 mb-4';
                streamingBubble.id = `streaming-${streamId}`;

                // Get character avatar for assistant
                const character = characters.find(c => c.id === selectedCharacterId);
                const avatarUrl = character?.avatar_url || 'data/Icons/AI.png';

                streamingBubble.innerHTML = `
        <img src="${avatarUrl}" class="w-12 h-12 rounded-full object-cover">
        <div class="message-content streaming-content p-3 rounded-lg bg-accent-color"></div>
    `;

                chatWindow.appendChild(streamingBubble);

                // Check if user is at the bottom before scrolling to new message
                const previousIsAtBottom = isUserAtBottom;
                if (previousIsAtBottom) {
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                }

                // Show the cancel button
                const cancelControl = $('#stream-controls');
                if (cancelControl) {
                    cancelControl.classList.remove('hidden');
                }

                try {
                    abortController = new AbortController();

                    const response = await fetch(`${API_BASE_URL}/api/chat/stream`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            character_id: selectedCharacterId,
                            chat_id: selectedChatId,
                            message: message,
                            mode: 'chat',
                            user_persona: userPersonaInput.value,
                            llm_settings: getLLMSettings(),
                        }),
                        signal: abortController.signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder('utf-8');

                    while (true) {
                        const { done, value } = await reader.read();

                        if (done) break;

                        const chunk = decoder.decode(value);

                        try {
                            const lines = chunk.split('\n\n');

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const jsonStr = line.substring(6);

                                    if (jsonStr === '[DONE]') break;

                                    try {
                                        const data = JSON.parse(jsonStr);

                                        if (data.type === 'content' && data.content) {
                                            assistantMessage += data.content;

                                            // Update the streaming bubble with new content
                                            updateStreamingBubble(streamingBubble, assistantMessage);
                                        } else if (data.type === 'done') {
                                            break;
                                        }
                                    } catch (parseError) {
                                        const cleanContent = line.substring(6).trim();
                                        if (cleanContent && !cleanContent.startsWith('[')) {
                                            assistantMessage += cleanContent;
                                            updateStreamingBubble(streamingBubble, assistantMessage);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            const cleanContent = chunk.trim();
                            if (cleanContent && !cleanContent.startsWith('[')) {
                                assistantMessage += cleanContent;
                                updateStreamingBubble(streamingBubble, assistantMessage);
                            }
                        }
                    }

                    // Add complete message to chat history and remove streaming bubble
                    chatHistory.push({ role: 'assistant', content: assistantMessage });

                    if (streamingBubble) {
                        streamingBubble.remove();
                    }

                    appendMessage('assistant', assistantMessage, userMessageIndex + 1);

                } catch (error) {
                    console.error("Streaming error:", error);
                    // Handle cancellation properly
                    if (error.name === 'AbortError') {
                        console.log("Stream was cancelled");
                        // Remove the streaming bubble immediately to prevent duplicate
                        if (streamingBubble && streamingBubble.parentNode) {
                            streamingBubble.remove();
                        }
                        // The user message is already in the frontend chatHistory at index 'userMessageIndex'.
                        // We need to save it to the backend if it's not already there.
                        // However, the backend might have already saved it implicitly during streaming if streaming started successfully.
                        // The safest way to ensure consistency is to rely on the frontend state for the cancelled scenario
                        // and potentially sync the full history back to the backend or save the user message explicitly.
                        // Saving the user message explicitly is safer here.
                        try {
                            // Save the user message to the backend history file
                            const userMessageSaved = await saveMessageToServer(selectedCharacterId, selectedChatId, 'user', message);
                            if (!userMessageSaved) {
                                console.error("Failed to save user message to server on cancel.");
                                // Decide how to handle this failure (e.g., warn user, keep in frontend only temporarily)
                            } else {
                                console.log("User message saved to server on cancel.");
                            }
                        } catch (saveUserError) {
                            console.error("Error saving user message to server on cancel:", saveUserError);
                        }

                        // Only save partial assistant message if we have content and it's not empty
                        if (assistantMessage && assistantMessage.trim() !== '') {
                            try {
                                // Save the partial assistant message to backend
                                const aiMessageSaved = await apiCall(`/chats/${selectedCharacterId}/${selectedChatId}/add_message`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ role: 'assistant', content: assistantMessage })
                                });
                                // Add the partial assistant message to local history
                                // Note: We might need to add the user message to local history again if it wasn't there initially,
                                // but since we pushed it initially, it should be there already.
                                // Add the AI message after the user message.
                                // The user message index is userMessageIndex, so AI should be userMessageIndex + 1
                                // But if other messages were added since then, we should push it.
                                // The safest way is to push it, as renderChatHistory will handle the order.
                                chatHistory.push({ role: 'assistant', content: assistantMessage });
                                appendMessage('assistant', assistantMessage, chatHistory.length - 1); // Use new index
                                console.log("Partial AI message saved to server and UI on cancel.");
                            } catch (saveError) {
                                console.error("Failed to save partial AI message:", saveError);
                   
                                // The user message is already handled above or was initially added.
                            }
                        } else {
                            console.log("No partial AI message to save on cancel.");
                            // The user message was handled above. The streaming bubble is removed.
                    
                        }
                        return; // Exit early if cancelled
                    } else {
                        // Show error in chat for other errors
                        if (streamingBubble) {
                            streamingBubble.innerHTML = `<div class="p-3 rounded-lg bg-red-100 text-red-800">Error: ${error.message}</div>`;
                        }
                    }
                } finally {
    isGenerating = false;
    isStreaming = false;
    // Hide the cancel button when done
    if (cancelControl) {
        cancelControl.classList.add('hidden');
    }
    if (abortController) {
        abortController = null;
    }
    
    // Ensure we keep our current chat selected after streaming
    if (selectedCharacterId && selectedChatId) {
        try {
            await selectChat(selectedChatId);
        } catch (error) {
            console.error("Failed to reselect current chat:", error);
        }
    }

                }
            };

            // Update the streaming bubble function to properly handle content

            // Add cancellation function (already exists but here for completeness)
            const cancelStreaming = () => {
                if (abortController) {
                    abortController.abort();
                    isGenerating = false;

                    // Hide the cancel button
                    const cancelControl = $('#stream-controls');
                    if (cancelControl) {
                        cancelControl.classList.add('hidden');
                    }
                }
            };

            // Make sure the cancel button has an event listener
            const cancelStreamBtn = $('#cancel-stream-btn');
            if (cancelStreamBtn) {
                cancelStreamBtn.addEventListener('click', cancelStreaming);
            }


            const handleSaveCharacter = async (e) => {
                e.preventDefault();
                const name = $('#char-name').value.trim();
                const description = $('#char-desc').value.trim();
                const avatarInput = $('#char-avatar');

                // Handle both URL input and file upload
                let avatar_url = '';
                if (avatarInput.files && avatarInput.files[0]) {
                    // If a file is selected, you'll need to implement file upload logic
                    // This requires backend support for image uploads
                    const formData = new FormData();
                    formData.append('image', avatarInput.files[0]);

                    try {
                        // Change this part of your JS code:
                        const response = await fetch('/api/upload-image', {
                            method: 'POST',
                            body: formData
                        });

                        const result = await response.json();
                        avatar_url = result.url; // Assuming backend returns the uploaded image URL
                    } catch (error) {
                        console.error('Image upload failed:', error);
                        alert('Failed to upload avatar');
                        return;
                    }

                } else {
                    avatar_url = avatarInput.value.trim(); // Fallback to URL input
                }

                if (!name || !description) return;

                const newChar = await apiCall('/characters', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, description, avatar_url }),
                });

                addCharModal.classList.add('hidden');
                addCharForm.reset();
                await fetchAndRenderCharacters();
                selectCharacter(newChar.id);
            };

            const updateChatSelectionUI = (charId, selectedChatId) => {
                const allChatButtons = document.querySelectorAll(`#chats-for-${charId} button[data-chat-id]`);
                allChatButtons.forEach(btn => {
                    if (btn.dataset.chatId === selectedChatId) {
                        btn.classList.add('bg-accent-color');
                        btn.style.backgroundColor = 'var(--accent-color)';
                    } else {
                        btn.classList.remove('bg-accent-color');
                    }
                });
            };

            const editMessage = async (index) => {
                if (!selectedCharacterId || !selectedChatId) {
                    console.error("Cannot edit message: No character or chat selected");
                    return;
                }

                if (index < 0 || index >= chatHistory.length) {
                    console.error("Invalid message index for editing:", index);
                    return;
                }

                const message = chatHistory[index];
                const content = message.content;

                // Create edit modal
                const existingModal = document.getElementById('edit-message-modal');
                if (existingModal) {
                    document.body.removeChild(existingModal);
                }

                const editModal = document.createElement('div');
                editModal.id = 'edit-message-modal';
                editModal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
                editModal.innerHTML = `
        <div class="bg-secondary rounded-lg p-6 w-full max-w-2xl shadow-xl">
            <h3 class="text-xl font-bold mb-4">Edit Message</h3>
            <textarea id="edit-message-text" rows="10" 
                class="w-full bg-accent-color border border-border-color rounded-lg p-3 focus:outline-none focus:ring-2 focus:ring-accent-color"
                placeholder="Edit your message here...">${content}</textarea>
            <div class="flex justify-end space-x-3 mt-4">
                <button id="cancel-edit" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg">Cancel</button>
                <button id="save-edit" class="px-4 py-2 bg-accent-color hover:bg-accent-hover text-white rounded-lg">Save Changes</button>
            </div>
        </div>
    `;

                document.body.appendChild(editModal);

                const saveBtn = editModal.querySelector('#save-edit');
                const cancelBtn = editModal.querySelector('#cancel-edit');
                const textarea = editModal.querySelector('#edit-message-text');

                // Auto-resize textarea
                const resizeTextarea = () => {
                    textarea.style.height = 'auto';
                    textarea.style.height = `${Math.min(textarea.scrollHeight, 400)}px`;
                };

                textarea.addEventListener('input', resizeTextarea);
                resizeTextarea(); // Initial resize

                saveBtn.addEventListener('click', async () => {
                    const newContent = textarea.value.trim();
                    if (newContent === '') return;

                    try {
                        // Send update to backend
                        const response = await apiCall(`/chats/${selectedCharacterId}/${selectedChatId}/update_message`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ index, content: newContent })
                        });

                        // Update local chat history
                        chatHistory[index].content = newContent;
                        renderChatHistory();

                        document.body.removeChild(editModal);
                    } catch (error) {
                        console.error("Failed to update message:", error);
                        alert("Failed to save changes");
                    }
                });

                cancelBtn.addEventListener('click', () => {
                    document.body.removeChild(editModal);
                });

                // Close modal when clicking outside
                editModal.addEventListener('click', (e) => {
                    if (e.target === editModal) {
                        document.body.removeChild(editModal);
                    }
                });
            };

            const style = document.createElement('style');
            style.textContent = `
    #edit-message-modal textarea {
        resize: none;
    }
`;
            document.head.appendChild(style);

            // Update the message actions click handler to include edit functionality
            chatWindow.addEventListener('click', (e) => {
                const regenBtn = e.target.closest('.regenerate-btn');
                const deleteBtn = e.target.closest('.delete-btn');
                const editBtn = e.target.closest('.edit-btn');

                if (regenBtn) regenerateMessage(parseInt(regenBtn.dataset.index));
                if (deleteBtn) deleteMessage(parseInt(deleteBtn.dataset.index));
                if (editBtn) editMessage(parseInt(editBtn.dataset.index));
            });


            const deleteCharacter = async (charId) => {
                if (!confirm('Are you sure you want to delete this character and all their chats?')) return;

                try {
                    await apiCall(`/characters/${charId}`, { method: 'DELETE' });
                    await fetchAndRenderCharacters();
                    // Reset UI
                    chatHeaderText.textContent = "Select a character";
                    chatInputArea.classList.add('hidden');
                    newChatBtn.classList.add('hidden');
                    emptyState.classList.remove('hidden');
                    selectedCharacterId = null;
                    selectedChatId = null;
                } catch (error) {
                    console.error("Failed to delete character:", error);
                }
            };

            // --- Helper & Init Functions ---
            const getLLMSettings = () => ({
                temperature: parseFloat(tempSlider.value),
                repetition_penalty: parseFloat(repPenSlider.value),
                min_p: parseFloat(minPSlider.value),
            });

            const saveLLMSettings = () => {
                localStorage.setItem('llmSettings', JSON.stringify(getLLMSettings()));
            };

            const loadSettings = () => {
                // Persona
                userPersonaInput.value = localStorage.getItem('userPersona') || '';
                userAvatarInput.value = localStorage.getItem('userAvatar') || '';

                // LLM Settings
                const savedLLMSettings = JSON.parse(localStorage.getItem('llmSettings'));
                if (savedLLMSettings) {
                    tempSlider.value = savedLLMSettings.temperature;
                    repPenSlider.value = savedLLMSettings.repetition_penalty;
                    minPSlider.value = savedLLMSettings.min_p;
                }
                tempValue.textContent = tempSlider.value;
                repPenValue.textContent = repPenSlider.value;
                minPValue.textContent = minPSlider.value;
                // Theme
                const savedTheme = localStorage.getItem('theme') || 'dark';
                themeSelector.value = savedTheme;
                applyTheme(savedTheme);
            };

            // --- Event Listeners ---
            userAvatarInput.addEventListener('input', () => {
                localStorage.setItem('userAvatar', userAvatarInput.value);
            });

            userAvatarUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (!file.type.startsWith('image/')) {
                    alert('Please select an image file.');
                    e.target.value = ''; // Clear the input
                    return;
                }

                const formData = new FormData();
                formData.append('image', file);

                try {
                    const response = await fetch('/api/upload-image', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.status}`);
                    }

                    const result = await response.json();
                    const uploadedUrl = result.url;

                    // Update the URL input field and local storage
                    userAvatarInput.value = uploadedUrl;
                    localStorage.setItem('userAvatar', uploadedUrl);

                    // Optional: Clear the file input after successful upload
                    e.target.value = '';
                } catch (error) {
                    console.error('Error uploading user avatar:', error);
                    alert('Failed to upload avatar. Please try again.');
                    e.target.value = ''; // Clear the input on error
                }
            });
            document.addEventListener('DOMContentLoaded', async () => {
                loadSettings();
                const cancelStreamBtn = $('#cancel-stream-btn');
                if (cancelStreamBtn) {
                    cancelStreamBtn.addEventListener('click', cancelStreaming);
                }

                await fetchAndRenderCharacters();
            });

            chatWindow.addEventListener('scroll', () => {
                const scrollTop = chatWindow.scrollTop;
                const scrollHeight = chatWindow.scrollHeight;
                const clientHeight = chatWindow.clientHeight;

                isUserAtBottom = (scrollHeight - scrollTop - clientHeight) <= 5; // Within 5px of bottom

                // For the case where user scrolls up and then AI starts streaming
                shouldAutoScroll = isUserAtBottom;
            });

            characterList.addEventListener('click', (e) => {
                const charItem = e.target.closest('.character-item');
                const chatItem = e.target.closest('button[data-chat-id]');
                const deleteCharBtn = e.target.closest('[data-delete-char]');
                const editCharBtn = e.target.closest('[data-edit-char]');
                const deleteChatBtn = e.target.closest('button[title="Delete Chat"]');

                if (charItem) {
                    selectCharacter(charItem.dataset.id);
                }
                if (chatItem) selectChat(chatItem.dataset.chatId);
                if (deleteCharBtn) deleteCharacter(deleteCharBtn.dataset.deleteChar);
                if (editCharBtn) openEditCharacterModal(editCharBtn.dataset.editChar);
                if (deleteChatBtn) {
                    const chatContainer = deleteChatBtn.closest('button[data-chat-id]');
                    if (chatContainer && selectedCharacterId) {
                        deleteChat(selectedCharacterId, chatContainer.dataset.chatId);
                    }
                }
            });


            newChatBtn.addEventListener('click', async () => {
                if (!selectedCharacterId) return;
                const newChatId = await createNewChat(selectedCharacterId);
                await fetchAndRenderChatList(selectedCharacterId);
                selectChat(newChatId);
            });

            // Forms & Modals
            chatForm.addEventListener('submit', handleSendMessage);
            addCharBtn.addEventListener('click', () => addCharModal.classList.remove('hidden'));
            cancelAddCharBtn.addEventListener('click', () => addCharModal.classList.add('hidden'));
            addCharForm.addEventListener('submit', handleSaveCharacter);

            // Message Actions
            chatWindow.addEventListener('click', (e) => {
                const regenBtn = e.target.closest('.regenerate-btn');
                const deleteBtn = e.target.closest('.delete-btn');
                const editBtn = e.target.closest('.edit-btn');

                if (regenBtn) regenerateMessage(parseInt(regenBtn.dataset.index));
                if (deleteBtn) deleteMessage(parseInt(deleteBtn.dataset.index));
                if (editBtn) editMessage(parseInt(editBtn.dataset.index));
            });

            // UI & Settings
            // Add this after your existing sidebarToggle listener:
            sidebarToggle.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                mainContainer.classList.toggle('sidebar-hidden');

                // Force reflow for mobile Safari
                if (/Mobi|Android/i.test(navigator.userAgent)) {
                    const chatArea = $('#chat-area');
                    const sidebar = $('#sidebar');

                    // Temporarily disable pointer events to prevent conflicts
                    sidebar.style.pointerEvents = 'none';
                    setTimeout(() => {
                        sidebar.style.pointerEvents = '';
                    }, 300);
                }
            });

            // Add these lines at the end of your DOMContentLoaded event listener:
            document.addEventListener('touchmove', function (e) {
                const sidebar = $('#sidebar');
                const chatArea = $('#chat-area');

                // If we're touching inside the sidebar, allow its scrolling
                if (e.target.closest('#sidebar') && !mainContainer.classList.contains('sidebar-hidden')) {
                    return; // Let sidebar scroll normally
                }

                // Prevent default scrolling when in certain states
                const isSidebarOpen = !mainContainer.classList.contains('sidebar-hidden');
                const touchY = e.touches[0].clientY;
                const touchX = e.touches[0].clientX;

                if (isSidebarOpen && touchX < 50) { // Touch near left edge
                    // Allow sidebar to be swiped open
                    return;
                }
            }, { passive: false });

            // Also add this for better mobile scrolling:
            document.body.addEventListener('touchmove', function (e) {
                const settingsAccordion = $('#settings-accordion');

                if (e.target.closest('#settings-accordion') &&
                    settingsAccordion.scrollHeight > settingsAccordion.clientHeight) {
                    // Allow settings to scroll independently
                    e.stopPropagation();
                }
            }, { passive: false });


            // Add this to handle touch events properly on mobile
            document.addEventListener('touchstart', function (e) {
                if (e.target.closest('#sidebar') && mainContainer.classList.contains('sidebar-hidden')) {
                    // Allow scrolling in sidebar when it's hidden
                    e.stopPropagation();
                }
            }, { passive: false });

            userPersonaInput.addEventListener('input', () => localStorage.setItem('userPersona', userPersonaInput.value));
            [tempSlider, repPenSlider, minPSlider].forEach(slider => slider.addEventListener('input', saveLLMSettings));
            tempSlider.addEventListener('input', () => tempValue.textContent = tempSlider.value);
            repPenSlider.addEventListener('input', () => repPenValue.textContent = repPenSlider.value);
            minPSlider.addEventListener('input', () => minPValue.textContent = minPSlider.value);
            // Add the form submission handler:
            editCharForm.addEventListener('submit', handleSaveEditedCharacter);
            cancelEditCharBtn.addEventListener('click', () => editCharModal.classList.add('hidden'));
            // Add to your themeSelector change event listener:
            themeSelector.addEventListener('change', () => {
                const theme = themeSelector.value;
                localStorage.setItem('theme', theme);
                applyTheme(theme);

                // Add this line to show/hide markdown settings
                if (theme === 'custom') {
                    customColorsContainer.classList.remove('hidden');
                } else {
                    customColorsContainer.classList.add('hidden');
                }
            });

            // Update color picker event listeners:
            colorPickers.forEach(picker => {
                picker.addEventListener('input', (e) => {
                    saveAndApplyCustomColor(e.target.dataset.cssVar, e.target.value);

                    // Add this to update markdown colors when changed
                    if (picker.dataset.cssVar.startsWith('--')) {
                        const customTheme = JSON.parse(localStorage.getItem('customTheme')) || {};
                        customTheme[picker.dataset.cssVar] = picker.value;
                        localStorage.setItem('customTheme', JSON.stringify(customTheme));
                    }
                });
            });


            // Textarea auto-resize
            messageInput.addEventListener('input', () => {
                messageInput.style.height = 'auto';
                messageInput.style.height = `${messageInput.scrollHeight}px`;
            });
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    chatForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
                }
            });
        })();
      
        function renderMarkdown(text) {
    if (!text || typeof text !== 'string') return '';
    
    // First parse with marked
    const dirtyHtml = marked.parse(text);
    
    // Sanitize but allow q tags and other elements
    let cleanHtml = DOMPurify.sanitize(dirtyHtml, {
        ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'code', 'pre', 'blockquote', 'ul', 'ol', 'li', 'a', 'h1', 'h2', 'h3', 'q'],
        ALLOWED_ATTR: ['href', 'class', 'style'],
        FORBID_ATTR: ['on*'],
        FORBID_TAGS: ['script', 'iframe', 'form']
    });
    
    // Convert text that looks like quoted text to proper q elements
    // Only match quotes that are standalone or at the start/end of content
    cleanHtml = cleanHtml.replace(/<p[^>]*>([^<]*?)("([^"]*)")([^<]*?)<\/p>/g, function(match, before, quote, content, after) {
        return `<p${before}<q style="color: var(--markdown-quote); font-style: italic;">"${content}"</q>${after}</p>`;
    });
    
    return cleanHtml;
}


    </script>
</body>

</html>